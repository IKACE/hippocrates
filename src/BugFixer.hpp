#pragma once 
/**
 * 
 */

#include "llvm/IR/Module.h"
#include "llvm/IR/Instruction.h"
#include "llvm/IR/Function.h"

#include "BugReports.hpp"

namespace pmfix {

/**
 * Subclasses of FixGenerator insert and/or perform fixes for the various types
 * of bugs.
 * 
 * This contains some helper functions as well, like getting the right function
 * definitions for flush and fence functions.
 */
class FixGenerator {
private:

protected:
    llvm::Module &module_;

    llvm::Function *getClwbDefinition() const;

public:
    FixGenerator(llvm::Module &m) : module_(m) {}

    /** CORRECTNESS
     * All these functions return the new instruction they created (or a pointer
     * to the last instruction they created), or nullptr if they were not 
     * successful.
     */

    virtual llvm::Instruction *insertFlush(llvm::Instruction *i) = 0;

    virtual llvm::Instruction *insertFence(llvm::Instruction *i) = 0;
};

/**
 * This flavor of fix generator just has to insert the fix. No metadata or 
 * tracing needs to be added.
 */
class GenericFixGenerator : public FixGenerator {
private:

public:
    GenericFixGenerator(llvm::Module &m) : FixGenerator(m) {}

    virtual llvm::Instruction *insertFlush(llvm::Instruction *i) override;

    virtual llvm::Instruction *insertFence(llvm::Instruction *i) override;
};

/**
 * This flavor of fix generator has to insert both the appropriate fix and
 * insert PMTest trace events which validate the fix.
 */
class PMTestFixGenerator : public FixGenerator {
private:

public:
    PMTestFixGenerator(llvm::Module &m) : FixGenerator(m) {}

    virtual llvm::Instruction *insertFlush(llvm::Instruction *i) override;

    virtual llvm::Instruction *insertFence(llvm::Instruction *i) override;
};

/**
 * Runs all the fixing algorithms.
 * 
 * First, computes all the fixes that need to be performed. Then, removes any
 * redundancy of operations from the computed fixes. Then, runs the fix generator
 * over the reduced patch.
 */
class BugFixer {
private:
    llvm::Module &module_;
    TraceInfo &trace_;
    BugLocationMapper mapper_;

    /**
     * High-level description of the fix that needs to be applied.
     * 
     * (iangneal): the flush+fence combo exists because for that case, the fence
     * is applied after the instruction generated by adding the flush, so the
     * ordering of that fix matters.
     */
    enum FixType {
        ADD_FLUSH_ONLY,
        ADD_FENCE_ONLY,
        ADD_FLUSH_AND_FENCE,
        REMOVE_FLUSH_ONLY,
        REMOVE_FENCE_ONLY,
        REMOVE_FLUSH_AND_FENCE
    };

    std::unordered_map<llvm::Instruction*, FixType> fixMap_;

    /**
     * 
     */
    bool addFixToMapping(llvm::Instruction *i, FixType type);

    /**
     * Figure out how to fix the given bug and add the fix to the map.
     * 
     * Returns true if a new fix was added, false if an existing fix also fixes
     * the given bug. This is mostly used as debug information.
     */
    bool computeAndAddFix(const TraceEvent &te, int bug_index);

    /**
     * Run the fix generator to fix the specified bug.
     */
    bool fixBug(FixGenerator *fixer, llvm::Instruction *i, FixType fixType);

public:
    BugFixer(llvm::Module &m, TraceInfo &ti) : module_(m), trace_(ti), mapper_(m) {}

    /**
     * Returns true if modifications were made to the program.
     */
    bool doRepair(void);
};

}