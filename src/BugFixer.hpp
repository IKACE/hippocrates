#pragma once 
/**
 * 
 */

#include "llvm/IR/Module.h"
#include "llvm/IR/Instruction.h"
#include "llvm/IR/Function.h"

#include "FixGenerator.hpp"
#include "BugReports.hpp"

namespace pmfix {

/**
 * Runs all the fixing algorithms.
 * 
 * First, computes all the fixes that need to be performed. Then, removes any
 * redundancy of operations from the computed fixes. Then, runs the fix generator
 * over the reduced patch.
 */
class BugFixer {
private:
    llvm::Module &module_;
    TraceInfo &trace_;
    BugLocationMapper mapper_;

    /**
     * High-level description of the fix that needs to be applied.
     * 
     * (iangneal): the flush+fence combo exists because for that case, the fence
     * is applied after the instruction generated by adding the flush, so the
     * ordering of that fix matters.
     * 
     * (iangneal): There is no way to infer the safety of removing a fence, as 
     * it can effect the safety of concurrent memory modifications.
     * - Future work could be to combine with concurrency bug fixers?
     */
    enum FixType {
        ADD_FLUSH_ONLY,
        ADD_FENCE_ONLY,
        ADD_FLUSH_AND_FENCE,
        REMOVE_FLUSH_ONLY
        // ,
        // REMOVE_FENCE_ONLY,
        // REMOVE_FLUSH_AND_FENCE
    };

    /**
     * A description of the fix to be applied. This is essentially:
     *  1. The kind of fix.
     *  2. The location of the fix.
     *  3. The constraints on the fix.
     *      - I believe that this can essentially be ordering requirements, as
     *      in A => this => B, meaning this must post-dominate A and B must 
     *      post-dominate this.
     */
    struct FixDesc {
        FixType fixType;
        llvm::Instruction *fixLoc;
        llvm::Instruction *orderedAfter;
        llvm::Instruction *orderedBefore;
    };

    std::unordered_map<llvm::Instruction*, FixType> fixMap_;

    /**
     * Utility to update the fix map. This provides basic fix coalescing (i.e.,
     * purely redundant fixes or upgrading fixes from flush/fence only to 
     * flush+fence).
     * Returns true if a new fix was added, false if the fix would be redundant.
     * 
     * (iangneal): return value mostly for debugging.
     */
    bool addFixToMapping(llvm::Instruction *i, FixType type);

    /**
     * Handle fix generation for a missing persist call.
     */
    bool handleAssertPersisted(const TraceEvent &te, int bug_index);

    /**
     * Handle fix generation for a missing ordering call.
     * 
     * Since we cannot re-order stores, the only fix here is to insert a fence.
     */
    bool handleAssertOrdered(const TraceEvent &te, int bug_index);

    /**
     * Handle fix generation for a redundant flush.
     */
    bool handleRequiredFlush(const TraceEvent &te, int bug_index);

    /**
     * Iterate over the fix map and see if there's anywhere we can do some fixing.
     * 
     * We do this AFTER running all the fixers so that we have complete information.
     */
    bool runFixMapOptimization(void);

    /**
     * Figure out how to fix the given bug and add the fix to the map. Generally
     * will call a handler function based on the kind of fix that needs to be
     * applied after validating that the request is well-formed.
     * 
     * Returns true if a new fix was added, false if an existing fix also fixes
     * the given bug. This is mostly used as debug information.
     */
    bool computeAndAddFix(const TraceEvent &te, int bug_index);

    /**
     * Run the fix generator to fix the specified bug.
     */
    bool fixBug(FixGenerator *fixer, llvm::Instruction *i, FixType fixType);

public:
    BugFixer(llvm::Module &m, TraceInfo &ti) 
        : module_(m), trace_(ti), mapper_(m) {}

    /**
     * Do the program repair!
     * 
     * This follows these general steps:
     * 
     * 1. Compute all initial fixes.
     * 2. Optimize fixes.
     * 3. Apply.
     * 
     * Returns true if modifications were made to the program.
     */
    bool doRepair(void);
};

}