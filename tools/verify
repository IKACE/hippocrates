#! /usr/bin/env python3
'''
    This script fully automates running tests, applying the fixer, and 
    validating that the fixed binaries no longer report bugs.
'''

from argparse import ArgumentParser
from copy import deepcopy
from enum import Enum, auto
from IPython import embed
from pathlib import Path
from pprint import pprint

import os
import shlex
import subprocess
import yaml

def assert_is_type(x, t):
    assert isinstance(x, t), f'"{x}" is type {type(x)}, not {t}'
 
def assert_is_path(*args):
    for x in args:
        assert_is_type(x, Path)


class ToolTypes(Enum):
    PMTEST = auto()
    PMEMCHECK = auto()
    PMDK_UNIT_TEST = auto()
    NONE = auto()

class ToolRunner:
    def __init__(self, target_name, exe_path, bc_path, tool_type, suite):
        assert_is_path(exe_path, bc_path)
        assert_is_type(tool_type, ToolTypes)
        self.pmemcheck_path = Path(r'${PMCHK_BIN_DIR}/valgrind')
        assert self.pmemcheck_path.exists(), f'{str(self.pmemcheck_path)} does not exist!'

        self.exe_path = exe_path
        self.bc_path = bc_path
        self.tool_type = tool_type
        self.suite = suite
        self.target = target_name

        fixed_postfix = '.fixed'
        if tool_type == ToolTypes.PMDK_UNIT_TEST:
            fixed_postfix = '.static-debug'
        self.exe_fixed_path = Path(str(exe_path) + fixed_postfix)

    def in_suite(self, suite):
        if suite == 'all' or suite == self.suite:
            return True
        return False

    def _run_pmtest(self):
        return True

    def _run_pmemcheck(self):
        return True

    def _run_pmdk_unit_test(self):
        '''
            We get the trace from the log file.
        '''
        # Need to set the PATH so the scripts can find the pmemcheck tool
        new_env = deepcopy(os.environ)
        if 'LD_LIBRARY_PATH' not in new_env:
            new_env['LD_LIBRARY_PATH'] = f'{str(self.exe_path.parent)}'
        else:
            new_env['LD_LIBRARY_PATH'] += f':{str(self.exe_path.parent)}'
        new_env['PATH'] = f'{str(self.pmemcheck_path.parent)}:{new_env["PATH"]}'

        # -1. Parse some values
        test_file = self.exe_path.parent.name.split("_")[-2]
        assert 'TEST' in test_file, 'Bad parsing!'
        test_num = test_file.replace('TEST', '')
        assert test_num.isnumeric(), 'Bad parsing!'
        test_num = int(test_num)

        # 0. Cleanup old logs, if any.
        pmemcheck_log = self.exe_path.parent / f'pmemcheck{test_num}.log'
        if pmemcheck_log.exists():
            pmemcheck_log.unlink()

        # 1. Run initial test
        runtests_str = f'./RUNTESTS_{self.exe_path.parent.name}' 
        runtests_args = shlex.split(f'{runtests_str} -b debug -p force-enable {self.exe_path.parent.name} -s {test_file}')
        # res = subprocess.run(runtests_args, cwd=self.exe_path.parent.parent, 
        #     env=new_env, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        res = subprocess.run(runtests_args, cwd=self.exe_path.parent.parent, env=new_env)
        if res.returncode == 0:
            embed()
        assert (res.returncode != 0), 'Test was successful, meaning no bugs!'
        assert pmemcheck_log.exists(), f'pmemcheck log "{str(pmemcheck_log)}" does not exist!'

        os.sync()

        # 2. Get trace from log file
        assert pmemcheck_log.exists(), 'Log not created!'
        parse_script = Path(__file__).parent.absolute() / 'parse-trace'
        assert parse_script.exists(), 'parser not available!'
        trace_file = pmemcheck_log.parent / f'pmemcheck{test_num}.trace'
        parse_arg_str = f'{str(parse_script)} pmemcheck {str(pmemcheck_log)} -o {str(trace_file)}'
        parse_args = shlex.split(parse_arg_str)
        print(f'{parse_arg_str}')

        res = subprocess.run(parse_args)
        res.check_returncode()
        assert trace_file.exists()

        # 3. Link the bitcode with the library so that opt can find the functions.
        # -- First, ensure bitcode was auto-extracted properly.
        # -- We DON'T extract here for build reasons.
        shared_objects = [f for f in self.exe_path.parent.iterdir() if '.so' in f.name and '.bc' not in f.name]
        shared_bc = [f.parent / (f.name + '.bc') for f in shared_objects]
        # for so, bc in zip(shared_objects, shared_bc):
        #     extract_args = shlex.split(f'extract-bc {so} -o {bc}')
        #     res = subprocess.run(extract_args)
        #     res.check_returncode()

        # embed()

        # --- Get the required libraries
        ldd_args = shlex.split(f'ldd {str(self.exe_path)}')
        res = subprocess.run(ldd_args, stdout=subprocess.PIPE)
        res.check_returncode()

        libs = [ l.strip().split()[0] for l in res.stdout.decode().split('\n') if l]
        self.bc_linked_path = self.bc_path.parent / (self.bc_path.name + '.linked')

        # --- Report which libraries didn't pull through
        to_link = []
        for lib in libs:
            matching_bc = [bc for bc in shared_bc if lib in bc.name]
            if not matching_bc:
                print(f'Could not link {lib}. Continuing...')
                continue

            assert len(matching_bc) == 1, f'Too many options!'
            bc = matching_bc[0]
            assert bc.exists(), f'Bad cmake build! {bc.name} does not exist!'
            to_link += [bc]

        argstr = f'llvm-link-8 -o {str(self.bc_linked_path)} {str(self.bc_path)}'
        for bc in to_link:
            argstr += f' --override={str(bc)}'
            
        link_args = shlex.split(argstr)
        res = subprocess.run(link_args)
        res.check_returncode()

        # 4. Run the fixer script
        fixer_script = Path(__file__).parent.absolute() / 'apply-fixer'
        if self.exe_fixed_path.exists():
            self.exe_fixed_path.unlink()
        fixer_arg_str = (f'{str(fixer_script)} {str(self.bc_linked_path)} '
            f'{str(trace_file)} -o {str(self.exe_fixed_path)} --extra-opt-args='
            f'"-fix-summary-file={self.exe_path.parent.name}_summary.txt"')
        print(fixer_arg_str)
        fixer_args = shlex.split(fixer_arg_str)
        res = subprocess.run(fixer_args)
        res.check_returncode()
        assert self.exe_fixed_path.exists(), 'Fixer did not succeed!'

        # 5. Re-run the unit tests, see if we fixed it!
        runtests_str = f'{runtests_str} -b static-debug -p force-enable {self.exe_path.parent.name} -s {test_file}'
        runtests_args = shlex.split(runtests_str)
        res = subprocess.run(runtests_args, cwd=self.exe_path.parent.parent, env=new_env)
        # res = subprocess.run(runtests_args, cwd=self.exe_path.parent.parent, 
        #     env=new_env, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        print(runtests_str)
        assert (res.returncode != 1), 'Test failed!'

        return True

    def run(self):
        print(f'{self.exe_path}: {self.tool_type.name}')
        # assert self.exe_path.exists(), f'{self.exe_path.name} does not exist!'
        # assert self.bc_path.exists(), f'{self.bc_path.name} was not extracted!'

        if self.tool_type == ToolTypes.PMTEST:
            return self._run_pmtest()
        elif self.tool_type == ToolTypes.PMEMCHECK:
            return self._run_pmemcheck()
        elif self.tool_type == ToolTypes.PMDK_UNIT_TEST:
            return self._run_pmdk_unit_test()
        else:
            return False

def get_test_list():
    '''
        List of:
            (test_executable, test_bitcode, tool_to_use)
    '''
    target_list = r'${TEST_TARGET_LIST}'.split(';')
    exe_list = [ Path(x) for x in r'${TEST_EXE_LIST}'.split(';') ]
    bc_list = [ Path(x) for x in r'${TEST_BC_LIST}'.split(';') ]
    tool_list = [ ToolTypes[x] for x in r'${TEST_TOOL_LIST}'.split(';') ]
    suite_list = [ x.lower() for x in r'${TEST_SUITE_LIST}'.split(';') ]

    # Do some sanity checking 

    for x, y in zip(exe_list, bc_list):
        assert (f'{str(x)}.bc' == str(y)), f'{str(x)}.bc != {str(y)}'
        # assert x.exists(), f'{x} must be built!'
        # assert y.exists(), f'{y} must be extracted!'
    
    for s in suite_list:
        assert s, 'Suite cannot be empty!'

    suites = set(suite_list + ['all'])

    test_list = list(zip(target_list, exe_list, bc_list, tool_list, suite_list))

    return test_list, sorted(target_list), sorted(list(suites))

def run_test(runner):
    # 1. Run the test and gather the initial trace.
    success = runner.run()
    if success:
        print(f'1. {runner.target} ran successfully.')
    else:
        raise Exception(f'{runner.target} failed!')
    
    # 2. Parse the trace.

    # 3. Apply the fix.

    # 4. Re-run the fixed test.

    # 5. Parse the trace from the fixed test.

    # 6. Assert that the bugs are fixed.


def run_all(args, test_list):
    for target, exe, bc, tool, suite in test_list:
        r = ToolRunner(target, exe, bc, tool, suite)
        if not r.in_suite(args.suite):
            print(f'{r.target} in suite {r.suite}, skipping')
        else:
            run_test(r)

def run_target(args, test_list):
    for target, exe, bc, tool, suite in test_list:
        r = ToolRunner(target, exe, bc, tool, suite)
        if r.target == args.target:
            run_test(r)

def main():
    test_list, targets, suites = get_test_list()

    parser = ArgumentParser(description=(r'Verify the ${CMAKE_PROJECT_NAME} by '
        'running tests, applying fixes, then verifying all the bugs are gone.'))
    parser.add_argument('suite', type=str, choices=suites, default='all',
                        nargs='?', help='Which set of tests to run')
    parser.add_argument('--target', '-t', type=str, choices=targets, 
                        help='Which target to run.')
    args = parser.parse_args()

    if args.target is not None:
        print(f'Running target "{args.target}"')
        run_target(args, test_list)
    else:
        print(f'Running suite "{args.suite}"')
        run_all(args, test_list)


if __name__ == '__main__':
    main()  