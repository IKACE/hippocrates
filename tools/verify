#! /usr/bin/env python3
'''
    This script fully automates running tests, applying the fixer, and 
    validating that the fixed binaries no longer report bugs.
'''

from argparse import ArgumentParser
from enum import Enum, auto
from pathlib import Path
from pprint import pprint

def assert_is_type(x, t):
    assert isinstance(x, t), f'"{x}" is type {type(x)}, not {t}'
 
def assert_is_path(*args):
    for x in args:
        assert_is_type(x, Path)


class ToolTypes(Enum):
    PMTEST = auto()
    PMEMCHECK = auto()
    NONE = auto()

class ToolRunner:
    def __init__(self, exe_path, tool_type):
        assert_is_path(exe_path)
        assert_is_type(tool_type, ToolTypes)
        self.exe_path = exe_path
        self.tool_type = tool_type
        self.suite = exe_path.parent.name

    def target(self):
        return self.exe_path.name

    def in_suite(self, suite):
        if suite == 'all' or suite == self.suite:
            return True
        return False

    def _run_pmtest(self):
        return True

    def _run_pmemcheck(self):
        pmemcheck_path = Path(r'${PMCHK_BIN_DIR}/valgrind')
        assert pmemcheck_path.exists(), f'{str(pmemcheck_path)} does not exist!'
        return True

    def run(self):
        print(f'{self.exe_path}: {self.tool_type.name}')
        if self.tool_type == ToolTypes.PMTEST:
            return self._run_pmtest()
        elif self.tool_type == ToolTypes.PMEMCHECK:
            return self._run_pmemcheck()
        else:
            return False

def get_test_list():
    '''
        List of:
            (test_executable, test_bitcode, tool_to_use)
    '''
    exe_list = r'${TEST_EXE_LIST}'.split(';')
    bc_list = r'${TEST_BC_LIST}'.split(';')
    tool_list = r'${TEST_TOOL_LIST}'.split(';')
    test_list = [ (Path(x), Path(y), ToolTypes[z]) for x, y, z in 
                    zip(exe_list, bc_list, tool_list)]
    for x, y, _ in test_list:
        assert (f'{str(x)}.bc' == str(y)), 'EXE list and BC list not matching up!!!'
        assert x.exists(), f'{x} must be built!'
        assert y.exists(), f'{y} must be extracted!'

    suites = set([x[0].parent.name for x in test_list] + ['all'])

    return test_list, sorted(list(suites))

def run_test(exe, bc, tool, suite):
    # 1. Run the test and gather the initial trace.
    r = ToolRunner(exe, tool)
    if not r.in_suite(suite):
        print(f'{r.target()} in suite {r.suite}, skipping')
        return
        
    success = r.run()
    if success:
        print(f'1. {r.target()} ran successfully.')
    else:
        raise Exception(f'{r.target()} failed!')
    
    # 2. Parse the trace.

    # 3. Apply the fix.

    # 4. Re-run the fixed test.

    # 5. Parse the trace from the fixed test.

    # 6. Assert that the bugs are fixed.


def run_all(args, test_list):
    for exe, bc, tool in test_list:
        run_test(exe, bc, tool, args.suite)

def main():
    test_list, suites = get_test_list()

    parser = ArgumentParser(description=(r'Verify the ${CMAKE_PROJECT_NAME} by '
        'running tests, applying fixes, then verifying all the bugs are gone.'))
    parser.add_argument('suite', type=str, choices=suites, default='all',
                        help='Which set of tests to run')
    args = parser.parse_args()

    run_all(args, test_list)


if __name__ == '__main__':
    main()