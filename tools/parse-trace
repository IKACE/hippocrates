#! /usr/bin/env python3

from argparse import ArgumentParser
from pathlib import Path

import re
import yaml

from IPython import embed

class BugReport:
    def __init__(self, output_file):
        assert isinstance(output_file, Path)
        self.output_file = output_file
        self.trace = []

    def _add_trace_event(self, **kwargs):
        self.trace += [kwargs]

    def add_pm_update(self, timestamp, addr, length, file, lineno):
        self._add_trace_event(timestamp=timestamp, event='STORE', address=addr, 
                              length=length, file=file, line=lineno, is_bug=False)

    def add_pm_flush(self, timestamp, addr, length, file, lineno):
        self._add_trace_event(timestamp=timestamp, event='FLUSH', address=addr, 
                              length=length, file=file, line=lineno, is_bug=False)

    def add_pm_fence(self, timestamp, file, lineno):
        self._add_trace_event(timestamp=timestamp, event='FENCE', file=file, 
                              line=lineno, is_bug=False)
    
    def add_pm_is_persist(self, timestamp, addr, length, is_persist, file, lineno):
        self._add_trace_event(timestamp=timestamp, event='ASSERT_PERSISTED',
                              address=addr, length=length, 
                              file=file, line=lineno, is_bug=not is_persist)

    def add_pm_is_ordered(self, timestamp, addr_a, len_a, addr_b, len_b, 
                          is_ordered, file, lineno):
        self._add_trace_event(timestamp=timestamp, event='ASSERT_ORDERED', 
            address_a=addr_a, length_a=len_a, address_b=addr_b, length_b=len_b,
            is_bug=not is_ordered, file=file, line=lineno)
    
    def dump(self):
        with self.output_file.open('w') as f:
            yaml.dump(self.trace, f, indent=4)
        print(f'Report written to {str(self.output_file)}')


def parse_common(input_file, output_file):
    assert(isinstance(input_file, Path) and isinstance(output_file, Path))
    assert(input_file.exists())

COLOR_RE = re.compile('\\033\[\d+m')
def strip_color(word):
    ''' Remove the color ASCII sequence. '''
    removed = COLOR_RE.sub('', word)
    return removed

def parse_pmtest(input_file, output_file):
    parse_common(input_file, output_file)

    # List of tuples; (time, event, line). Time is an arbitrary int
    timestamp = 0
    pmtest_trace = []

    pmtest_events = ['_ASSIGN', '_FLUSH', '_FENCE', '_PERSIST', '_ORDER',
                     '_COMMIT', '_BARRIER', '_TRANSACTIONDELIM', '_ENDING',
	                 '_TRANSACTIONBEGIN', '_TRANSACTIONEND', '_TRANSACTIONADD', 
                     '_EXCLUDE', '_INCLUDE']
    pmtest_errors = ['PERSIST ERROR', 'ASSIGN ERROR', 'ORDER ERROR', 
                     'TRANSACTIONEND ERROR', 'SENDTRACE ERROR']

    with input_file.open() as f:
        for l in f:
            # Remove whitespace and color codes
            line = strip_color(l.strip())
            parts = line.split(' ')
            cmd = parts[0]
            # strip colon from end
            err = f'{parts[0]} {parts[1][:-1]}'
            if cmd in pmtest_events:
                pmtest_trace += [ (timestamp, cmd, line) ]
                timestamp += 1
            elif err in pmtest_errors:
                pmtest_trace += [ (timestamp, err, line) ]
                # Don't increment timestamp as the errors aren't code events.

    
    # Now we can parse the trace.
    report = BugReport(output_file)

    for i in range(len(pmtest_trace)):
        timestamp, event, line = pmtest_trace[i]
        parts = line.split(' ')
        if '_ASSIGN' == event:
            # Operation: store value into PM
            report.add_pm_update(timestamp, int(parts[1], base=16), int(parts[2]), 
                                 parts[3], int(parts[4]))
        elif '_FLUSH' == event:
            # Operation: issue durability barrier in PM
            report.add_pm_flush(timestamp, int(parts[1], base=16), int(parts[2]), 
                                parts[3], int(parts[4]))
        elif '_FENCE' == event:
            # Operation: issue global ordering barrier
            report.add_pm_fence(timestamp, parts[1], int(parts[2]))

        elif '_PERSIST' == event:
            # Assertion: check if the given address range is persisted or not.
            is_persist = True
            if i + 1 < len(pmtest_trace) and \
                    pmtest_trace[i+1][1] == 'PERSIST ERROR':
                is_persist = False
            report.add_pm_is_persist(timestamp, int(parts[1], base=16), int(parts[2]),
                                     is_persist, parts[3], int(parts[4]))
        elif 'PERSIST ERROR' == event:
            # Bug report from '_PERSIST'. Skip this since we already processed
            # it with the '_PERSIST' event.
            pass
        
        elif '_ORDER' == event:
            # Assertion: check if the first address range is persisted before 
            # the second range.
            is_ordered = True
            if i + 1 < len(pmtest_trace) and \
                    pmtest_trace[i+1][1] == 'ORDER ERROR':
                is_ordered = False
            report.add_pm_is_ordered(timestamp, int(parts[1], base=16), int(parts[2]), 
                                     int(parts[3], base=16), int(parts[4]), 
                                     is_ordered, parts[5], int(parts[6]))
        elif 'ORDER ERROR' == event:
            pass

        else:
            raise Exception(f'Unsupported event type {event}!\t\n"{line}"')

    return report

def parse_pmemcheck(input_file, output_file):
    '''
        First, we need to parse the event trace. Then, we have to parse the list
        of detected errors.

        It's a little annoying that pmemcheck doesn't support as many options
    '''
    parse_common(input_file, output_file)

    timestamp = 0
    # List of tuples; (time, event, file, line). Time is an arbitrary int
    # --- In this version, line can None
    # --- Event is also either a single string or a list
    pmemcheck_trace = []

    def insert_trace_event(event, filepath=None, line=None):
        nonlocal pmemcheck_trace, timestamp
        pmemcheck_trace += [(timestamp, event, filepath, line)]
        timestamp += 1

    def parse_trace(line):
        events = [e.strip() for e in line.split('|')]
        for event in events:
            if 'START' in event:
                pass
            elif 'STOP' in event:
                break
            elif 'FENCE' == event:
                insert_trace_event(event)
            elif 'FLUSH' in event:
                insert_trace_event(event.split(';'))
            elif 'STORE' in event:
                parts = event.split(':')
                # -- Removes the code address from the end, which is unimportant
                addr = parts[0].split(';')[0:-1]
                # -- Removes function name, which is unnecessary 
                filepath = parts[1].split('(')[-1].split(')')[0]
                line = int(parts[2].replace(')', ''))
                insert_trace_event(addr, filepath=filepath, line=line)
            else:
                raise Exception(f'Unsure how to parse event "{event}"')


    start_trace = False
    stop_trace = False

    with input_file.open() as f:
        lines = f.readlines()
        i = 0
        while i < len(lines):
            if not start_trace:
                if 'START|' in lines[i]:
                    start_trace = True
                    parse_trace(lines[i])
            elif start_trace and not stop_trace:
                if '|STOP' in lines[i]:
                    stop_trace = True
                else:
                    parse_trace(lines[i])
            elif start_trace and stop_trace:
                # Parse the bug reports themselves.
                print(f'TODO: {lines[i]}')
            else:
                raise Exception('How did we get here?')
            i += 1
    
    # Now we can assemble the trace.
    report = BugReport(output_file)

    for ts, event, filepath, line in pmemcheck_trace:
        if isinstance(event, str):
            assert(filepath is None)
            assert(line is None)
            if event == 'FENCE':
                report.add_pm_fence(ts, filepath, line)
            else: 
                raise Exception(f'Bad event! {event}')
        elif isinstance(event, list):
            event_type = event[0]
            address = int(event[1], base=16)
            if event_type == 'FLUSH':
                assert(filepath is None)
                assert(line is None)
                length = int(event[2], base=16)
                report.add_pm_flush(ts, address, length, filepath, line)
            elif event_type == 'STORE':
                assert(filepath is not None)
                assert(line is not None and isinstance(line, int))
                #data = int(event[1], base=16) # unused data field
                length = int(event[3], base=16)
                report.add_pm_update(ts, address, length, filepath, line)
            else:
                raise Exception(f'Bad event type! {event_type}')
        else:
            raise Exception(f'Unsure how to handle event {str(event)} of type {type(event)}')

    return report


FORMATS = {
    'pmtest': parse_pmtest,
    'pmemcheck': parse_pmemcheck
}

def main():
    parser = ArgumentParser()
    
    parser.add_argument('format', type=str, choices=FORMATS.keys(), 
                        help='what bug-finder format to parse')
    parser.add_argument('input_file', type=Path, help='input file')
    parser.add_argument('--output-file', '-o', type=Path, 
                        default=Path('report.yaml'), 
                        help='output file. Default is report.yaml')

    args = parser.parse_args()
 
    parse_fn = FORMATS[args.format]
    report = parse_fn(args.input_file, args.output_file)
    if report is None or not isinstance(report, BugReport):
        raise Exception((f'parse_fn returned {report} when a BugReport should '
                         'have been returned!'))
    
    report.dump()

if __name__ == '__main__':
    main()