#! /usr/bin/env python3

from argparse import ArgumentParser
from enum import Enum, auto
from pathlib import Path

import re
import yaml

from IPython import embed

class BugReportSource(Enum):
    GENERIC = auto()
    PMTEST = auto()

class BugReport:
    def __init__(self, output_file):
        assert isinstance(output_file, Path)
        self.output_file = output_file
        self.trace = []
        self.metadata = {}

    def set_source(self, src):
        assert(isinstance(src, BugReportSource))
        self.metadata['source'] = src.name

    def _validate_metadata(self):
        ''' Check that all the required metadata as been setup. '''
        assert ('source' in self.metadata), 'call set_source(BugReportSource)!'

    def _add_trace_event(self, **kwargs):
        self.trace += [kwargs]

    def add_pm_update(self, timestamp, addr, length, file, lineno):
        self._add_trace_event(timestamp=timestamp, event='STORE', address=addr, 
                              length=length, file=file, line=lineno, is_bug=False)

    def add_pm_flush(self, timestamp, addr, length, file, lineno):
        self._add_trace_event(timestamp=timestamp, event='FLUSH', address=addr, 
                              length=length, file=file, line=lineno, is_bug=False)

    def add_pm_fence(self, timestamp, file, lineno):
        self._add_trace_event(timestamp=timestamp, event='FENCE', file=file, 
                              line=lineno, is_bug=False)
    
    def add_pm_is_persist(self, timestamp, addr, length, is_persist, file, lineno):
        self._add_trace_event(timestamp=timestamp, event='ASSERT_PERSISTED',
                              address=addr, length=length, 
                              file=file, line=lineno, is_bug=not is_persist)

    def add_pm_is_ordered(self, timestamp, addr_a, len_a, addr_b, len_b, 
                          is_ordered, file, lineno):
        self._add_trace_event(timestamp=timestamp, event='ASSERT_ORDERED', 
            address_a=addr_a, length_a=len_a, address_b=addr_b, length_b=len_b,
            is_bug=not is_ordered, file=file, line=lineno)
    
    def dump(self):
        self._validate_metadata()
        with self.output_file.open('w') as f:
            report = {'trace': self.trace, 'metadata': self.metadata}
            yaml.dump(report, f)
        print(f'Report written to {str(self.output_file)}')


def parse_common(input_file, output_file):
    assert(isinstance(input_file, Path) and isinstance(output_file, Path))
    assert(input_file.exists())

COLOR_RE = re.compile('\\033\[\d+m')
def strip_color(word):
    ''' Remove the color ASCII sequence. '''
    removed = COLOR_RE.sub('', word)
    return removed

def parse_pmtest(input_file, output_file):
    parse_common(input_file, output_file)

    # List of tuples; (time, event, line). Time is an arbitrary int
    timestamp = 0
    pmtest_trace = []

    pmtest_events = ['_ASSIGN', '_FLUSH', '_FENCE', '_PERSIST', '_ORDER',
                     '_COMMIT', '_BARRIER', '_TRANSACTIONDELIM', '_ENDING',
	                 '_TRANSACTIONBEGIN', '_TRANSACTIONEND', '_TRANSACTIONADD', 
                     '_EXCLUDE', '_INCLUDE']
    pmtest_errors = ['PERSIST ERROR', 'ASSIGN ERROR', 'ORDER ERROR', 
                     'TRANSACTIONEND ERROR', 'SENDTRACE ERROR']

    with input_file.open() as f:
        for l in f:
            # Remove whitespace and color codes
            line = strip_color(l.strip())
            parts = line.split(' ')
            cmd = parts[0]
            # strip colon from end
            err = f'{parts[0]} {parts[1][:-1]}'
            if cmd in pmtest_events:
                pmtest_trace += [ (timestamp, cmd, line) ]
                timestamp += 1
            elif err in pmtest_errors:
                pmtest_trace += [ (timestamp, err, line) ]
                # Don't increment timestamp as the errors aren't code events.

    
    # Now we can parse the trace.
    report = BugReport(output_file)
    report.set_source(BugReportSource.PMTEST)

    for i in range(len(pmtest_trace)):
        timestamp, event, line = pmtest_trace[i]
        parts = line.split(' ')
        if '_ASSIGN' == event:
            # Operation: store value into PM
            report.add_pm_update(timestamp, int(parts[1], base=16), int(parts[2]), 
                                 parts[3], int(parts[4]))
        elif '_FLUSH' == event:
            # Operation: issue durability barrier in PM
            report.add_pm_flush(timestamp, int(parts[1], base=16), int(parts[2]), 
                                parts[3], int(parts[4]))
        elif '_FENCE' == event:
            # Operation: issue global ordering barrier
            report.add_pm_fence(timestamp, parts[1], int(parts[2]))

        elif '_PERSIST' == event:
            # Assertion: check if the given address range is persisted or not.
            is_persist = True
            if i + 1 < len(pmtest_trace) and \
                    pmtest_trace[i+1][1] == 'PERSIST ERROR':
                is_persist = False
            report.add_pm_is_persist(timestamp, int(parts[1], base=16), int(parts[2]),
                                     is_persist, parts[3], int(parts[4]))
        elif 'PERSIST ERROR' == event:
            # Bug report from '_PERSIST'. Skip this since we already processed
            # it with the '_PERSIST' event.
            pass
        
        elif '_ORDER' == event:
            # Assertion: check if the first address range is persisted before 
            # the second range.
            is_ordered = True
            if i + 1 < len(pmtest_trace) and \
                    pmtest_trace[i+1][1] == 'ORDER ERROR':
                is_ordered = False
            report.add_pm_is_ordered(timestamp, int(parts[1], base=16), int(parts[2]), 
                                     int(parts[3], base=16), int(parts[4]), 
                                     is_ordered, parts[5], int(parts[6]))
        elif 'ORDER ERROR' == event:
            pass

        else:
            raise Exception(f'Unsupported event type {event}!\t\n"{line}"')

    return report

def parse_pmemcheck(input_file, output_file):
    '''
        First, we need to parse the event trace. Then, we have to parse the list
        of detected errors.

        It's a little annoying that pmemcheck doesn't support as many options
    '''
    parse_common(input_file, output_file)

    timestamp = 0
    # List of tuples; (time, event, file, line). Time is an arbitrary int
    # --- In this version, line can None
    # --- Event is also either a single string or a list
    pmemcheck_trace = []

    def insert_trace_event(event, filepath, line):
        nonlocal pmemcheck_trace, timestamp
        pmemcheck_trace += [(timestamp, event, filepath, line)]
        timestamp += 1

    def parse_trace(line):
        events = [e.strip() for e in line.split('|')]
        for event in events:
            if 'START' in event:
                pass
            elif 'STOP' in event:
                break
            elif 'FENCE' in event:
                parts = event.split(':')
                event_type = parts[0].split(';')[0]
                # -- Removes function name, which is unnecessary 
                filepath = parts[1].split('(')[-1].split(')')[0]
                line = int(parts[2].replace(')', ''))
                insert_trace_event(event_type, filepath, line)
            elif 'STORE' in event or 'FLUSH' in event:
                parts = event.split(':')
                # -- Removes the code address from the end, which is unimportant
                addr = parts[0].split(';')[0:-1]
                # -- Removes function name, which is unnecessary 
                filepath = parts[1].split('(')[-1].split(')')[0]
                line = int(parts[2].replace(')', ''))
                insert_trace_event(addr, filepath, line)
            else:
                raise Exception(f'Unsure how to parse event "{event}"')

    start_trace = False
    stop_trace = False

    nbugs_re = re.compile(r'==\d+==\s+Number of stores not made persistent: (\d+)')
    nbugs_total = None
    nbugs_remaining = None
    last_bug_no = -1

    bug_re = re.compile(r'==\d+==\s+\[(\d+)\]\s+ at \w+: \w+ \((\S+)\) ==\d+==\s+Address: (\w+)\s+size: (\d+)\s+state: (\w+)')

    # We want to insert these in specific places
    # (addr, size, file, line) describes the original assignment
    # (state) describes the kind of bug
    # --- (state, addr, size, file, line)
    bugs = []

    with input_file.open() as f:
        lines = f.readlines()
        i = 0
        while i < len(lines):
            if not start_trace:
                if 'START|' in lines[i]:
                    start_trace = True
                    parse_trace(lines[i])
            elif start_trace and not stop_trace:
                if '|STOP' in lines[i]:
                    stop_trace = True
                else:
                    parse_trace(lines[i])
            elif start_trace and stop_trace and nbugs_total is None:
                # Parse the bug reports themselves.
                matches = nbugs_re.match(lines[i])
                if matches is not None:
                    nbugs_total = int(matches.group(1))
                    nbugs_remaining = nbugs_total
                assert('Stores not made persistent properly' in lines[i+1])
                i += 1
            elif nbugs_remaining is not None and nbugs_remaining > 0:
                # Finish getting the bug reports
                # Add another one, end of function does the rest
                print(f'R: {nbugs_remaining}/{nbugs_total}')
                # --- skips the rest of the stack trace
                st = 1
                while 'by' in lines[i+st]:
                    st += 1
                bug_report = f'{lines[i].strip()} {lines[i+st].strip()}'
                i += st
                matches = bug_re.match(bug_report)
                assert (matches is not None), f'"{bug_report}" does not match "{bug_re}"'
                bug_no = int(matches.group(1))
                filepath, line = matches.group(2).split(':')
                addr = int(matches.group(3), base=16)
                size = int(matches.group(4))
                state = matches.group(5)
                bugs += [(state, addr, size, filepath, int(line))]

                if bug_no != last_bug_no + 1:
                    print(f'{bug_no} != {last_bug_no + 1}')
                assert(bug_no == last_bug_no + 1)
                last_bug_no = bug_no

                nbugs_remaining -= 1    
            else:
                # End of interesting stuff.
                break
            i += 1
    
    # Now, we need to insert these bugs in the right place in the trace.
    for state, addr, size, filepath, line in bugs:
        # First, we need find assignments which would match the bug report
        matching_stores = []
        for ts, event, fp, ln in pmemcheck_trace:
            if isinstance(event, list) and event[0] == 'STORE' \
                and filepath == fp and line == ln \
                and addr == int(event[1], base=16) \
                and size == int(event[3], base=16):
                matching_stores += [(ts, event, fp, ln)]
        
        # Now, we need to make sure that these stores have the right issues
        # --- as in, the store is missing a flush or fence
        print('TODO: check for multiple matching')
        assert(len(matching_stores) == 1)

        # idx = pmemcheck_trace.index(matching_stores[0]) + 1
        # Just put them at the end if there aren't multiple matching traces.
        idx = len(pmemcheck_trace)
        pmemcheck_trace.insert(idx, (matching_stores[0][0], ['BUG', state, addr, size], filepath, line))

    # Now we can assemble the trace.
    report = BugReport(output_file)
    report.set_source(BugReportSource.GENERIC)

    for ts, event, filepath, line in pmemcheck_trace:
        if isinstance(event, str):
            if event == 'FENCE':
                report.add_pm_fence(ts, filepath, line)
            else: 
                raise Exception(f'Bad event! {event}')
        elif isinstance(event, list):
            event_type = event[0]
            if event_type == 'FLUSH':
                address = int(event[1], base=16)
                length = int(event[2], base=16)
                report.add_pm_flush(ts, address, length, filepath, line)
            elif event_type == 'STORE':
                address = int(event[1], base=16)
                #data = int(event[1], base=16) # unused data field
                length = int(event[3], base=16)
                report.add_pm_update(ts, address, length, filepath, line)
            elif event_type == 'BUG':
                report.add_pm_is_persist(ts, event[2], event[3], False, filepath, line)
            else:
                raise Exception(f'Bad event type! {event_type}')
        else:
            raise Exception(f'Unsure how to handle event {str(event)} of type {type(event)}')

    return report


FORMATS = {
    'pmtest': parse_pmtest,
    'pmemcheck': parse_pmemcheck
}

def main():
    parser = ArgumentParser()
    
    parser.add_argument('format', type=str, choices=FORMATS.keys(), 
                        help='what bug-finder format to parse')
    parser.add_argument('input_file', type=Path, help='input file')
    parser.add_argument('--output-file', '-o', type=Path, 
                        default=Path('report.yaml'), 
                        help='output file. Default is report.yaml')

    args = parser.parse_args()
 
    parse_fn = FORMATS[args.format]
    report = parse_fn(args.input_file, args.output_file)
    if report is None or not isinstance(report, BugReport):
        raise Exception((f'parse_fn returned {report} when a BugReport should '
                         'have been returned!'))
    
    report.dump()

if __name__ == '__main__':
    main()